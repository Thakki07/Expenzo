"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.colorOptionToThemedLightnessScale = exports.colorOptionToThemedAlphaScale = exports.legacyScales = exports.modernScales = void 0;
exports.generateAlphaScale = generateAlphaScale;
exports.generateLightnessScale = generateLightnessScale;
const cssSupports_1 = require("../cssSupports");
const constants_1 = require("./constants");
const legacy_1 = require("./legacy");
const utils_1 = require("./utils");
/**
 * Apply a prefix to a color scale
 * @param scale - The color scale to apply the prefix to
 * @param prefix - The prefix to apply
 * @returns The color scale with the prefix applied
 */
function applyScalePrefix(scale, prefix) {
    const result = {};
    for (const [shade, color] of Object.entries(scale)) {
        if (color !== undefined) {
            result[prefix + shade] = color;
        }
    }
    return result;
}
/**
 * Modern CSS alpha scale generation
 */
function generateModernAlphaScale(baseColor) {
    const scale = (0, utils_1.createEmptyColorScale)();
    constants_1.COLOR_SCALE.forEach(shade => {
        scale[shade] = (0, utils_1.generateAlphaColorMix)(baseColor, shade);
    });
    return scale;
}
/**
 * Legacy HSLA alpha scale generation
 */
function generateLegacyAlphaScale(baseColor) {
    const scale = (0, utils_1.createEmptyColorScale)();
    const parsedColor = legacy_1.colors.toHslaColor(baseColor);
    const baseWithoutAlpha = legacy_1.colors.setHslaAlpha(parsedColor, 0);
    constants_1.COLOR_SCALE.forEach((shade, index) => {
        var _a;
        const alpha = (_a = constants_1.ALPHA_VALUES[index]) !== null && _a !== void 0 ? _a : 1;
        const alphaColor = legacy_1.colors.setHslaAlpha(baseWithoutAlpha, alpha);
        scale[shade] = legacy_1.colors.toHslaString(alphaColor);
    });
    return scale;
}
/**
 * Modern CSS lightness scale generation
 */
function generateModernLightnessScale(baseColor) {
    const scale = (0, utils_1.createEmptyColorScale)();
    constants_1.COLOR_SCALE.forEach(shade => {
        scale[shade] = (0, utils_1.getSupportedColorVariant)(baseColor, shade);
    });
    return scale;
}
/**
 * Legacy HSLA lightness scale generation
 */
function generateLegacyLightnessScale(baseColor) {
    const scale = (0, utils_1.createEmptyColorScale)();
    const parsedColor = legacy_1.colors.toHslaColor(baseColor);
    // Set the base 500 shade
    scale['500'] = legacy_1.colors.toHslaString(parsedColor);
    // Calculate lightness steps
    const lightStep = (constants_1.LIGHTNESS_CONFIG.TARGET_LIGHT - parsedColor.l) / constants_1.LIGHT_SHADES.length;
    const darkStep = (parsedColor.l - constants_1.LIGHTNESS_CONFIG.TARGET_DARK) / constants_1.DARK_SHADES.length;
    // Generate light shades (lighter than base)
    constants_1.LIGHT_SHADES.forEach((shade, index) => {
        const lightnessIncrease = (index + 1) * lightStep;
        const lightColor = legacy_1.colors.changeHslaLightness(parsedColor, lightnessIncrease);
        scale[shade] = legacy_1.colors.toHslaString(lightColor);
    });
    // Generate dark shades (darker than base)
    constants_1.DARK_SHADES.forEach((shade, index) => {
        const lightnessDecrease = (index + 1) * darkStep * -1;
        const darkColor = legacy_1.colors.changeHslaLightness(parsedColor, lightnessDecrease);
        scale[shade] = legacy_1.colors.toHslaString(darkColor);
    });
    return scale;
}
/**
 * Processes color input and validates it
 */
function processColorInput(color) {
    if (!color)
        return null;
    if (typeof color === 'string') {
        return { baseColor: color };
    }
    // If it's already a color scale object, extract the base color (500 shade)
    if (color['500']) {
        return {
            baseColor: color['500'],
            userScale: color,
        };
    }
    // If it's an object, check if it has any valid shade keys
    if (typeof color === 'object') {
        const hasValidShadeKeys = constants_1.ALL_SHADES.some((shade) => color[shade]);
        if (hasValidShadeKeys && !color['500']) {
            // Has valid shade keys but missing 500 - this is an error
            throw new Error('You need to provide at least the 500 shade');
        }
        // No valid shade keys - treat as invalid input
        if (!hasValidShadeKeys) {
            return null;
        }
    }
    return null;
}
/**
 * Merges user-defined colors with generated scale
 */
function mergeWithUserScale(generated, userScale) {
    if (!userScale)
        return generated;
    return { ...generated, ...userScale };
}
/**
 * Unified alpha scale generator that automatically chooses between modern and legacy implementations
 * @param color - Base color string or existing color scale
 * @returns Complete color scale with alpha variations
 */
function generateAlphaScale(color) {
    const processed = processColorInput(color);
    if (!processed) {
        return (0, utils_1.createEmptyColorScale)();
    }
    const { baseColor, userScale } = processed;
    // Generate scale using modern or legacy implementation
    const generated = cssSupports_1.cssSupports.modernColor()
        ? generateModernAlphaScale(baseColor)
        : generateLegacyAlphaScale(baseColor);
    // Merge with user-provided colors if any
    return mergeWithUserScale(generated, userScale);
}
/**
 * Unified lightness scale generator that automatically chooses between modern and legacy implementations
 * @param color - Base color string or existing color scale
 * @returns Complete color scale with lightness variations
 */
function generateLightnessScale(color) {
    const processed = processColorInput(color);
    if (!processed) {
        return (0, utils_1.createEmptyColorScale)();
    }
    const { baseColor, userScale } = processed;
    // Generate scale using modern or legacy implementation
    const generated = cssSupports_1.cssSupports.modernColor()
        ? generateModernLightnessScale(baseColor)
        : generateLegacyLightnessScale(baseColor);
    // Merge with user-provided colors if any
    return mergeWithUserScale(generated, userScale);
}
/**
 * Direct access to modern scale generators (for testing or when modern CSS is guaranteed)
 */
exports.modernScales = {
    generateAlphaScale: generateModernAlphaScale,
    generateLightnessScale: generateModernLightnessScale,
};
/**
 * Direct access to legacy scale generators (for testing or compatibility)
 */
exports.legacyScales = {
    generateAlphaScale: generateLegacyAlphaScale,
    generateLightnessScale: generateLegacyLightnessScale,
};
/**
 * Converts a color scale to CSS color strings
 * Works with both modern CSS (color-mix, relative colors) and legacy HSLA
 */
function convertScaleToCssStrings(scale) {
    const result = {};
    for (const [shade, color] of Object.entries(scale)) {
        if (color && color !== undefined) {
            // For modern CSS color-mix values, we keep them as-is since they're already valid CSS
            // For legacy HSLA values, they're already in HSLA format
            result[shade] = color;
        }
    }
    return result;
}
/**
 * Applies prefix to a color scale and converts to CSS color strings
 */
function prefixAndConvertScale(scale, prefix) {
    const cssScale = convertScaleToCssStrings(scale);
    return applyScalePrefix(cssScale, prefix);
}
/**
 * Converts a color option to a themed alpha scale with prefix
 * Returns CSS color values (modern color-mix/relative colors or legacy HSLA)
 * @param colorOption - Color input (string or alpha scale object)
 * @param prefix - Prefix to apply to scale keys
 * @returns Prefixed CSS color scale or undefined
 */
const colorOptionToThemedAlphaScale = (colorOption, prefix) => {
    if (!colorOption) {
        return undefined;
    }
    // Generate alpha scale using the unified scale generator
    const scale = generateAlphaScale(colorOption);
    // Convert to CSS strings and apply prefix
    return prefixAndConvertScale(scale, prefix);
};
exports.colorOptionToThemedAlphaScale = colorOptionToThemedAlphaScale;
/**
 * Converts a color option to a themed lightness scale with prefix
 * Returns CSS color values (modern color-mix/relative colors or legacy HSLA)
 * @param colorOption - Color input (string or lightness scale object)
 * @param prefix - Prefix to apply to scale keys
 * @returns Prefixed CSS color scale or undefined
 */
const colorOptionToThemedLightnessScale = (colorOption, prefix) => {
    if (!colorOption) {
        return undefined;
    }
    // Generate lightness scale using the unified scale generator
    const scale = generateLightnessScale(colorOption);
    // Convert to CSS strings and apply prefix
    return prefixAndConvertScale(scale, prefix);
};
exports.colorOptionToThemedLightnessScale = colorOptionToThemedLightnessScale;
