"use strict";
/**
 * CSS-based color manipulation utilities
 * Uses color-mix() and relative color syntax when supported
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.colors = void 0;
const cssSupports_1 = require("../cssSupports");
const constants_1 = require("./constants");
const utils_1 = require("./utils");
/**
 * CSS-based color manipulation utilities
 * Uses color-mix() and relative color syntax when supported
 */
exports.colors = {
    /**
     * Lightens a color by a percentage
     */
    lighten: (color, percentage = 0) => {
        if (!color)
            return undefined;
        if (cssSupports_1.cssSupports.relativeColorSyntax()) {
            // Use relative color syntax for precise lightness control
            const lightnessIncrease = percentage * 100; // Convert to percentage
            return (0, utils_1.createRelativeColorString)(color, 'h', 's', `calc(l + ${lightnessIncrease}%)`);
        }
        if (cssSupports_1.cssSupports.colorMix()) {
            // Use color-mix as fallback
            const mixPercentage = Math.min(percentage * 100, constants_1.MODERN_CSS_LIMITS.MAX_LIGHTNESS_MIX);
            return (0, utils_1.createColorMixString)(color, 'white', mixPercentage);
        }
        return color; // Return original if no CSS support
    },
    /**
     * Makes a color transparent by a percentage
     */
    makeTransparent: (color, percentage = 0) => {
        if (!color || color.toString() === '')
            return undefined;
        if (cssSupports_1.cssSupports.colorMix()) {
            const alphaPercentage = Math.max((1 - percentage) * 100, constants_1.MODERN_CSS_LIMITS.MIN_ALPHA_PERCENTAGE);
            return (0, utils_1.createAlphaColorMixString)(color, alphaPercentage);
        }
        return color; // Return original if no CSS support
    },
    /**
     * Makes a color completely opaque
     */
    makeSolid: (color) => {
        if (!color)
            return undefined;
        if (cssSupports_1.cssSupports.relativeColorSyntax()) {
            // Set alpha to 1 using relative color syntax
            return (0, utils_1.createRelativeColorString)(color, 'h', 's', 'l', '1');
        }
        if (cssSupports_1.cssSupports.colorMix()) {
            // Mix with itself at 100% to remove transparency
            return `color-mix(in srgb, ${color}, ${color} 100%)`;
        }
        return color; // Return original if no CSS support
    },
    /**
     * Sets the alpha value of a color
     */
    setAlpha: (color, alpha) => {
        const clampedAlpha = Math.min(Math.max(alpha, constants_1.COLOR_BOUNDS.alpha.min), constants_1.COLOR_BOUNDS.alpha.max);
        if (cssSupports_1.cssSupports.relativeColorSyntax()) {
            // Use relative color syntax for precise alpha control
            return (0, utils_1.createRelativeColorString)(color, 'h', 's', 'l', clampedAlpha.toString());
        }
        if (cssSupports_1.cssSupports.colorMix()) {
            // Use color-mix with transparent
            const percentage = clampedAlpha * 100;
            return (0, utils_1.createAlphaColorMixString)(color, percentage);
        }
        return color; // Return original if no CSS support
    },
    /**
     * Adjusts color for better contrast/lightness
     */
    adjustForLightness: (color, lightness = 5) => {
        if (!color)
            return undefined;
        if (cssSupports_1.cssSupports.colorMix()) {
            // Use color-mix with white for lightness adjustment - more conservative approach
            const mixPercentage = Math.min(lightness * constants_1.MODERN_CSS_LIMITS.MIX_MULTIPLIER, constants_1.MODERN_CSS_LIMITS.MAX_LIGHTNESS_ADJUSTMENT);
            return (0, utils_1.createColorMixString)(color, 'white', mixPercentage);
        }
        return color; // Return original if no CSS support
    },
};
